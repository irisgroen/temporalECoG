function [epochs, channels, t, srate, opts] = tde_selectData(data, opts)

% Select electrodes and epochs from the struct generated by tde_getData.m
% according to criteria specified in opts.
%
% [epochs, channels, t, srate, opts] = tde_selectData(data, [opts])
% 
% Outputs subject-concatenated version of data after following steps:
%
% 1. Removing bad epochs and channels with many bad epochs (opts.epoch_)
% 2. Removing channels that do not match inclusion criteria (opts.elec_)
% 3. Conversion to percent signal change (using opts.baseline_time)
% 4. Averaging across trials (optional)
% 5. Combining all subjects together in a matrix of time x conditions x
%    electrodes that can be used for model fitting (see tde_fitModel.m).
% 
% If opts.doplots = true, will generate lots of plots illustrating epoch
% selection and electrode selection, which will be saved to
% <tderootPath>/analysis/figures.
%
% See tde_getData.m, ecog_normalizeEpochs.m ecog_selectElectrodes.m
% ecog_selectEpochs.m ecog_averageEpochs.m
%
% 2022 Iris Groen

%% Check inputs

% <data>
if ~exist('data', 'var') || isempty(data), error('Please provide the data struct outputted by tde_getData.m as input'); end 

% <opts>
if ~exist('opts','var') || isempty(opts), opts = struct(); end

if ~isfield(opts, 'stimnames') || isempty(opts.stimnames)
    opts.stimnames = {'CRF-1','CRF-2', 'CRF-3','CRF-4', 'CRF-5',...
                      'ONEPULSE-1','ONEPULSE-2', 'ONEPULSE-3','ONEPULSE-4', 'ONEPULSE-5','ONEPULSE-6',...
                      'TWOPULSE-1','TWOPULSE-2', 'TWOPULSE-3','TWOPULSE-4', 'TWOPULSE-5','TWOPULSE-6'};
end
if ~isfield(opts, 'areanames'), opts.areanames = {'V1','V2','V3','V3a','V3b','hV4','LO1','LO2','TO1','TO2','IPS'}; end

if ~isfield(opts,'stim_on') || isempty(opts.stim_on)
    opts.stim_on = [0.05 0.85]; % time period across which stimulus is presented
end
if ~isfield(opts,'baseline_time') || isempty(opts.baseline_time)
    opts.baseline_time = [-0.1 0]; % time period across which to compute normalization baseline
end
if ~isfield(opts,'epoch_jump_thresh') || isempty(opts.epoch_jump_thresh)
    opts.epoch_jump_thresh = 200; % max jump in voltage allowed within stim_on period
end
if ~isfield(opts,'epoch_outlier_thresh') || isempty(opts.epoch_outlier_thresh)
    opts.epoch_outlier_thresh = 3; % xfold of the standard deviation of the maximum broadband values within each epoch
end
if ~isfield(opts,'elec_selection_method') || isempty(opts.elec_selection_method)
    opts.elec_selection_method = 'splithalf'; % thresh, splithalf, meanpredict
end
if ~isfield(opts,'elec_max_thresh') || isempty(opts.elec_max_thresh)
    opts.elec_max_thresh = 1; % minimum required maximal response in % signal change for electrode inclusion
end
if ~isfield(opts,'elec_mean_thresh') || isempty(opts.elec_mean_thresh)
    opts.elec_mean_thresh = 0; % minimum required mean response during stim_on period in % signal change
end
if ~isfield(opts,'elec_splithalf_thresh') || isempty(opts.elec_splithalf_thresh)
    opts.elec_splithalf_thresh = 0.22; % minimum required R2 between split halves of data
end
if ~isfield(opts,'elec_meanpredict_thresh') || isempty(opts.elec_meanpredict_thresh)
    opts.elec_meanpredict_thresh = 0; % minimum required R2 for prediction by mean (1 - (SSEresidual/SSEtotal)
end
if ~isfield(opts,'elec_exclude_depth') || isempty(opts.elec_exclude_depth)
    opts.elec_exclude_depth = true; % boolean
end
if ~isfield(opts,'average_trials') || isempty(opts.average_trials)
    opts.average_trials = true;  % boolean
end
if ~isfield(opts,'doplots') || isempty(opts.doplots)
    opts.doplots = true; % boolean
end
if ~isfield(opts,'plotsavedir') || isempty(opts.plotsavedir)
    opts.plotsavedir = fullfile(analysisRootPath, 'figures');
end

%% Initialize
savePlots         = opts.doplots;
plotSaveDir       = opts.plotsavedir;
plotSaveDir_epoch = fullfile(plotSaveDir, 'epochselection');
plotSaveDir_elecs = fullfile(plotSaveDir, 'electrodeselection');

% Make figure directories if they don't exist
if savePlots
    if ~exist(plotSaveDir_epoch,'dir'); mkdir(plotSaveDir_epoch); end
    if ~exist(plotSaveDir_elecs,'dir'); mkdir(plotSaveDir_elecs); end
end

% We will use both the voltage and broadband epochs in selection, but will
% output only the broadband epochs for the subsequent model testing step.
allEpochs   = []; % To be filled with broadband epochs across all subjects
allChannels = []; % To be filled with channel info across all subjects

%% Select data

for ii = 1:length(data) % Loop over subjects
    
    subject     = data{ii}.subject;
    epochs_b    = data{ii}.epochs_b;
    epochs_v    = data{ii}.epochs_v;
    t           = data{ii}.t;
    channels    = data{ii}.channels;
    events      = data{ii}.events;

    fprintf('[%s] Selecting data for subject %s \n',mfilename, subject);
          
    % Restrict selection to relevant stimuli only
    stim_idx = contains(events.trial_name, opts.stimnames);
    epochs_b = epochs_b(:, stim_idx, :);
    epochs_v = epochs_v(:, stim_idx, :);
    events = events(stim_idx, :);
    
    % Restrict selection to included channels only
    
    % Exclude depth electrodes
    if opts.elec_exclude_depth 
        chan_idx = ~contains(lower(channels.type), 'seeg');
        channels = channels(chan_idx,:);
        epochs_b = epochs_b(:,:,chan_idx);
        epochs_v = epochs_v(:,:,chan_idx);
    end  
    
    % Include only requested areas
    if ~isempty(opts.areanames)
        if ~iscell(opts.areanames),opts.areanames = {opts.areanames};end
        [~, ~, group_prob] = groupElecsByVisualArea(channels, 'probabilisticresample', opts.areanames);
        chan_idx = any(group_prob,2);
        if ~any(chan_idx)
            fprintf('[%s] Did not find matching electrodes in area %s for subject %s\n', mfilename, [opts.areanames{:}], subject);
            channels = [];
        else
            channels = channels(chan_idx,:);
            epochs_b = epochs_b(:,:,chan_idx);
            epochs_v = epochs_v(:,:,chan_idx);      
        end
    end
    
    if isempty(channels)
        fprintf('[%s] Did not find any matching electrodes for subject %s. Moving to next subject\n', mfilename, subject);
        continue
    else
        %% STEP 1 Baseline correction
        
        fprintf('[%s] Baseline correcting voltage epochs ......\n',mfilename);
        
        % Voltage trials 
        [epochs_v] = ecog_normalizeEpochs(epochs_v, t, opts.baseline_time, 'subtractwithintrial');
        channels.units = repmat({'%change'}, [height(channels),1]);

        fprintf('[%s] Converting broadband epochs to percent signal change...\n',mfilename);

        % Provide run index to perform separately for each run and session
        [~,~,task_idx]= unique(events.task_name);
        [~,~,ses_idx]= unique(events.session_name);
        [~,~,run_idx] = unique(events.run_name);
        [~,~,idx] = unique([task_idx ses_idx run_idx], 'rows');
        
        % Broadband trials 
        [epochs_b] = ecog_normalizeEpochs(epochs_b, t, opts.baseline_time, 'percentsignalchange', idx);

        %% STEP 2 Epoch selection
        
        fprintf('[%s] Removing bad epochs...\n',mfilename);

        [select_idx, max_epochs, outlier_thresh] = ecog_selectEpochs(epochs_v, epochs_b, t, opts);
        outlier_idx = ~select_idx;
        
        % Plot the included and excluded trials: all channels combined
        if savePlots
            fprintf('[%s] Plotting epoch selection ...\n',mfilename);
            % Make separate plots for different electrode groups
            groups = unique(channels.group);
            nGroups = length(groups);
            for jj = 1:nGroups
                chan_idx = find(strcmp(channels.group, groups{jj}));
                nChans = length(chan_idx);
                plotList = ones(nChans,1);
                % Split large HDgrid, otherwise plotting takes very long
                switch groups{jj}
                    case 'HDgrid'
                        plotList(round(nChans/3):round(nChans/3)*2) = 2;
                        plotList(round(nChans/3)*2:end) = 3;
                end
                for kk = 1:max(plotList)
                    figureName = sprintf('outlierepochs_allchans_sub-%s-%s-%d', subject, groups{jj}, kk);
                    figure('Name', figureName);hold on
                    chanstoPlot = chan_idx(plotList == kk);
                    outlier_idx_group = outlier_idx(:,chanstoPlot);
                    epochs_v_group = epochs_v(:,:,chanstoPlot);
                    epochs_b_group = epochs_b(:,:,chanstoPlot);        
                    if any(outlier_idx_group(:)) 
                        subplot(2,2,1); 
                        plot(t, epochs_v_group(:,outlier_idx_group)); axis tight
                        title('excluded epochs - voltage')
                        subplot(2,2,2); 
                        plot(t, epochs_b_group(:,outlier_idx_group)); axis tight
                        title('excluded epochs - broadband')
                    end
                    subplot(2,2,3); 
                    plot(t, epochs_v_group(:,~outlier_idx_group)); axis tight
                    title('included epochs - voltage')
                    subplot(2,2,4); 
                    plot(t, epochs_b_group(:,~outlier_idx_group)); axis tight
                    title('included epochs - broadband')
                    % Set axes
                    set(findall(gcf,'-property','FontSize'),'FontSize',14)
                    set(gcf, 'Position', [150 100 1400 600]);
                    % Save
                    saveas(gcf, fullfile(plotSaveDir_epoch, figureName), 'png'); close;
                end
            end
        end

        % Plot the outlier trials: individual plots
        if savePlots
            fprintf('[%s] Plotting removed epochs...\n',mfilename);

            for jj = 1:height(channels)
                % Skip plotting of depth electrodes if those are not included
                if opts.elec_exclude_depth && contains(lower(channels.type(jj)), 'seeg')
                    continue
                end 
                if any(outlier_idx(:,jj))
                    outliers_found = find(outlier_idx(:,jj));
                    nOutliers = length(outliers_found);
                    dim1 = round((nOutliers+1)/2);
                    dim2 = round((nOutliers+1)/dim1);
                    % plot
                    figureName = sprintf('outlierepochs_sub-%s_chan-%s-broadband', subject, channels.name{jj});
                    figure('Name', figureName); hold on;
                    subplot(dim2,dim1,1); hold on; title(channels.name{jj}); 
                    histogram(max_epochs(:,jj),100); line([outlier_thresh(jj) outlier_thresh(jj)], get(gca, 'YLim'), 'Color', 'r','LineStyle', ':', 'LineWidth', 2);
                    set(gca, 'fontsize', 14); xlabel('max pows'); ylabel('number of epochs');
                    for kk = 1:nOutliers
                        subplot(dim2,dim1,kk+1); 
                        ecog_plotSingleTimeCourse(t, epochs_b(:,outliers_found(kk),jj), [], [], sprintf('epoch %d %s', outliers_found(kk), events.trial_name{outliers_found(kk)}));    
                    end
                    set(gcf, 'Position', [150 100 300*dim1 300*dim2]);
                    saveas(gcf, fullfile(plotSaveDir_epoch, figureName), 'png'); close;
                end
            end
        end

        % Mask the broadband epochs to include only the selected epochs.
        epochs = epochs_b;
        epochs(:,outlier_idx) = nan;

        %% STEP 3 Select electrodes   
        fprintf('[%s] Selecting electrodes...\n',mfilename);

        [select_idx, R2, epochs_split] = ecog_selectElectrodes(epochs, channels, events, t, opts);
        channels.noiseceilingR2 = round(R2,2);
        epochs_selected = epochs(:,:,select_idx);
        channels_selected = channels(select_idx,:);
        
        if savePlots    
            
            fprintf('[%s] Plotting electrode selection...\n',mfilename);

            if ~isempty(epochs_split)
                for el = 1:height(channels)
                    figureName = sprintf('%s_%s_%s_%s', subject, channels.name{el}, channels.benson14_varea{el}, channels.wang15_mplbl{el});
                    figure;hold on;
                    plot(squeeze(epochs_split(1,el,:)), 'r','LineWidth', 2);
                    plot(squeeze(epochs_split(2,el,:)), 'b','LineWidth', 2);
                    axis tight
                    nSamp = size(epochs,1); nSampTot = nSamp * length(opts.stimnames);
                    set(gca, 'XTick', 1:nSamp:nSampTot, 'XTickLabel', opts.stimnames);
                    xtickangle(45)
                    title(sprintf('%s %s %s R2 = %0.2f', channels.name{el}, channels.benson14_varea{el}, channels.wang15_mplbl{el}, R2(el)));
                    scrSz = get(0, 'Screensize');
                    set(gcf, 'Position', scrSz);
                    set(findall(gcf,'-property','FontSize'),'FontSize',14)
                    saveas(gcf, fullfile(plotSaveDir_elecs, figureName), 'png'); close;
                end
            end

            % Compute mean across all trials
            mean_resp = mean(epochs,2,'omitnan');
            % Compute std deviations for plotting
            llim = (mean_resp - (std(epochs,0,2,'omitnan')));
            ulim = (mean_resp + (std(epochs,0,2,'omitnan')));
            mean_resp_sd = cat(2, llim, ulim);
            % Plot all channels
            nEl = size(mean_resp,3); 
            figureName = sprintf('viselec_%s_all', subject);
            figure('Name', figureName); plotDim1 = round(sqrt(nEl)); plotDim2 = ceil((nEl)/plotDim1);
            for el = 1:nEl
                subplot(plotDim1,plotDim2,el); hold on
                plotTitle = sprintf('%s %s %s ', channels.name{el}, channels.benson14_varea{el}, channels.wang15_mplbl{el});        
                ecog_plotSingleTimeCourse(t, mean_resp(:,:,el), squeeze(mean_resp_sd(:,:,el)), [], plotTitle);
                %if el == 1; xlabel('Time (s)'); ylabel('Broadband signal change');end
                set(gcf, 'Position', [150 100 1500 1250]);
            end
            saveas(gcf, fullfile(plotSaveDir_elecs, figureName), 'png'); close;
            % Plot selected channels
            figureName = sprintf('viselec_%s_selected', subject);
            figure('Name', figureName); 
            for el = 1:nEl
                if select_idx(el)
                    subplot(plotDim1,plotDim2,el); hold on
                    plotTitle = sprintf('%s %s %s ', channels.name{el}, channels.benson14_varea{el}, channels.wang15_mplbl{el});        
                    ecog_plotSingleTimeCourse(t, mean_resp(:,el), squeeze(mean_resp_sd(:,:,el)), [], plotTitle)    
                    set(gcf, 'Position', [150 100 1500 1250]);
                end
            end
            saveas(gcf, fullfile(plotSaveDir_elecs, figureName), 'png'); close;
        end

        % Select the channels
        epochs = epochs_selected;

        % Update channels table
        channels = channels_selected;

        %% STEP 4 average across trials, concatenate subjects

        % Average trials
        if opts.average_trials
            [epochs] = ecog_averageEpochs(epochs, events, opts.stimnames);   
        end

        % Concatenate the data across subjects
        allEpochs = cat(3, allEpochs, epochs);    

        % Remove a number of columns from channel table for readability, and
        % concatenate across subjects
        channels = removevars(channels, {'low_cutoff', 'high_cutoff', 'reference', 'group', 'bb_method', 'bb_bandwidth'});
        if isfield(summary(channels),'impedance'), channels = removevars(channels,'impedance');end
        allChannels = [allChannels; channels];
    end   
end

%% Finalize processing %%

epochs    = allEpochs;
channels  = allChannels;

% Check that all channels have same sample frequency
assert(length(unique(channels.sampling_frequency))==1);
srate = channels.sampling_frequency(1);

% Add an index column to channels
index = [1:height(channels)]';
channels = addvars(channels, index, 'Before', 'name'); 

end

